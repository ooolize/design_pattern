{"marks":[{"_id":"666ee6cc45699577f55fc6c9","createdAt":1718544076768,"updatedAt":0,"_objectStore":"marks","url":"https://web-highlights.com/blog/welcome/","tags":[],"text":"ghlig","type":"normal","completeText":"Welcome To Web Highlights 📚 🏷️ ✍️","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"H1","parentIndex":0,"textOffset":17},"endMeta":{"parentTagName":"H1","parentIndex":0,"textOffset":22},"text":"ghlig","id":"2db6567c-821a-4c31-a224-92f706a3c9c4","__isHighlightSource":{}},"domElementOffsetTop":213,"domElementOffsetLeft":1420,"title":"Welcome To Web Highlights 📚 🏷️ ✍️","_bookmark":"666ee6cc45699577f55fc6ca"},{"_id":"666ee7080968d573cc0d24d0","createdAt":1718544136201,"updatedAt":1718544206909,"_objectStore":"marks","url":"https://gpp.tkchu.me/observer.html","tags":[],"text":"“侵入式”链表","type":"normal","completeText":"后者的风格被称为“侵入式”链表，因为在对象内部使用链表侵入了对象本身的定义。 侵入式链表灵活性更小，但如我们所见，也更有效率。 在Linux核心这样的地方这种风格很流行。","mediaType":"blockquote","color":"#fb83b3","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":81,"textOffset":8},"endMeta":{"parentTagName":"P","parentIndex":81,"textOffset":15},"text":"“侵入式”链表","id":"5afe7fc2-91f8-439a-bc61-b1db9788e35d","__isHighlightSource":{}},"domElementOffsetTop":106,"domElementOffsetLeft":137,"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"666ee7080968d573cc0d24d1","richText":{"ops":[{"insert":"没懂\n"}]},"modifiedAt":1718544206909},{"_id":"666ee7780968d573cc0d24d2","createdAt":1718544248569,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/observer.html","tags":[],"text":"如你所见，从链表移除一个节点通常需要处理一些丑陋的特殊情况，应对头节点。 还可以使用指针的指针，实现一个更优雅的方案。","type":"normal","completeText":"如你所见，从链表移除一个节点通常需要处理一些丑陋的特殊情况，应对头节点。 还可以使用指针的指针，实现一个更优雅的方案。","mediaType":"blockquote","color":"#fb83b3","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":68,"textOffset":0},"endMeta":{"parentTagName":"P","parentIndex":68,"textOffset":59},"text":"如你所见，从链表移除一个节点通常需要处理一些丑陋的特殊情况，应对头节点。\n还可以使用指针的指针，实现一个更优雅的方案。","id":"dd78768c-00be-4a8f-9176-0204bfa82044","__isHighlightSource":{}},"domElementOffsetTop":-1,"domElementOffsetLeft":22,"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"666ee7080968d573cc0d24d1"},{"_id":"666ee7980968d573cc0d24d3","createdAt":1718544280512,"updatedAt":1718544289897,"_objectStore":"marks","url":"https://gpp.tkchu.me/observer.html","tags":[],"text":" 如果为了理解程序的一部分，两个交流的模块都需要考虑， 那就不要使用观察者模式，使用其他更加显式的东西。","type":"normal","completeText":"处理这个的指导原则很简单。 如果为了理解程序的一部分，两个交流的模块都需要考虑， 那就不要使用观察者模式，使用其他更加显式的东西。","mediaType":"blockquote","color":"#f8fc46","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":107,"textOffset":13},"endMeta":{"parentTagName":"P","parentIndex":107,"textOffset":65},"text":"\n如果为了理解程序的一部分，两个交流的模块都需要考虑，\n那就不要使用观察者模式，使用其他更加显式的东西。","id":"35e93e19-40f0-489f-b7f3-c2d4a7e486fd","__isHighlightSource":{}},"domElementOffsetTop":9072,"domElementOffsetLeft":236,"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"666ee7080968d573cc0d24d1","modifiedAt":1718544289897},{"_id":"666ee7bc0968d573cc0d24d4","createdAt":1718544316160,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/observer.html","tags":[],"text":"不相关的代码块","type":"normal","completeText":"观察者模式是一个让这些不相关的代码块互相交流，而不必打包成更大的块的好方法。 这在专注于一个特性或层面的单一代码块内不会太有用。","mediaType":"blockquote","color":"#f8fc46","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":109,"textOffset":11},"endMeta":{"parentTagName":"P","parentIndex":109,"textOffset":18},"text":"不相关的代码块","id":"0f65a698-9216-492f-b89a-dbec2af83615","__isHighlightSource":{}},"domElementOffsetTop":9205,"domElementOffsetLeft":202,"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"666ee7080968d573cc0d24d1"},{"_id":"666ee7c50968d573cc0d24d5","createdAt":1718544325328,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/observer.html","tags":[],"text":"专注于一个特性","type":"normal","completeText":"观察者模式是一个让这些不相关的代码块互相交流，而不必打包成更大的块的好方法。 这在专注于一个特性或层面的单一代码块内不会太有用。","mediaType":"blockquote","color":"#f8fc46","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":109,"textOffset":41},"endMeta":{"parentTagName":"P","parentIndex":109,"textOffset":48},"text":"专注于一个特性","id":"64bf4da8-2782-448e-8dd4-f3a0de12c88d","__isHighlightSource":{}},"domElementOffsetTop":9229,"domElementOffsetLeft":69,"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"666ee7080968d573cc0d24d1"},{"_id":"666ee7d00968d573cc0d24d6","createdAt":1718544336545,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/observer.html","tags":[],"text":"数据流编程","type":"normal","completeText":"就是这样，“哦，英雄的健康现在是7了？让我们把血条的宽度设为70像素。 过上一段时间，这会变得很沉闷。 计算机科学学术界和软件工程师已经用了很长时间尝试结束这种状况了。 这些方式被赋予了不同的名字：“数据流编程”，“函数反射编程”等等。","mediaType":"blockquote","color":"#f8fc46","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":124,"textOffset":100},"endMeta":{"parentTagName":"P","parentIndex":124,"textOffset":105},"text":"数据流编程","id":"a33e5103-0c78-4043-827d-cb7c82618eaa","__isHighlightSource":{}},"domElementOffsetTop":10078,"domElementOffsetLeft":308,"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"666ee7080968d573cc0d24d1"},{"_id":"667034993e6a0feaeb6c4e9f","createdAt":1718629529734,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/prototype.html","tags":[],"text":"我们需要将每个怪物有独立的类作为前提条件。 这绝对不是当今大多数游戏引擎运作的方法","type":"normal","completeText":"同时，这看上去没减少已存问题上的代码， 事实上还增添了些人为的问题。 我们需要将每个怪物有独立的类作为前提条件。 这绝对不是当今大多数游戏引擎运作的方法。","mediaType":"blockquote","color":"#fb83b3","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":22,"textOffset":35},"endMeta":{"parentTagName":"P","parentIndex":22,"textOffset":76},"text":"我们需要将每个怪物有独立的类作为前提条件。\n这绝对不是当今大多数游戏引擎运作的方法","id":"bce017a2-dee4-4e0a-a2ec-3825bae968e5","__isHighlightSource":{}},"domElementOffsetTop":3156,"domElementOffsetLeft":527,"title":"原型模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667034993e6a0feaeb6c4ea0"},{"_id":"66703dc4934b65ca1469bcf7","createdAt":1718631876448,"updatedAt":1718631898058,"_objectStore":"marks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"text":"静态类","type":"normal","completeText":"剩下的问题，何处我们应该使用真实的单例模式？ 说实话，我从来没有在游戏中使用全部的GoF模式。 为了保证实例是单一的，我通常简单地使用静态类。 如果这无效，我使用静态标识位，在运行时检测是不是只有一个实例被创建了。","mediaType":"blockquote","color":"#fb83b3","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":92,"textOffset":67},"endMeta":{"parentTagName":"P","parentIndex":92,"textOffset":70},"text":"静态类","id":"9e67ce9a-affa-43ce-bbec-df9d102847e2","__isHighlightSource":{}},"domElementOffsetTop":9634,"domElementOffsetLeft":421,"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"66703dc4934b65ca1469bcf8","modifiedAt":1718631898058},{"_id":"66703ddf934b65ca1469bcf9","createdAt":1718631903216,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"text":"静态标识位","type":"normal","completeText":"剩下的问题，何处我们应该使用真实的单例模式？ 说实话，我从来没有在游戏中使用全部的GoF模式。 为了保证实例是单一的，我通常简单地使用静态类。 如果这无效，我使用静态标识位，在运行时检测是不是只有一个实例被创建了。","mediaType":"blockquote","color":"#fb83b3","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":92,"textOffset":81},"endMeta":{"parentTagName":"P","parentIndex":92,"textOffset":86},"text":"静态标识位","id":"3b7bbddc-1414-4247-b650-e453c1bf0945","__isHighlightSource":{}},"domElementOffsetTop":9658,"domElementOffsetLeft":54,"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"66703dc4934b65ca1469bcf8"},{"_id":"66703e37934b65ca1469bcfa","createdAt":1718631991124,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"text":"便利的访问是我们使用单例的一个主要原因","type":"normal","completeText":"便利的访问是我们使用单例的一个主要原因。 这让我们在不同地方获取需要的对象更加容易。 这种便利是需要付出代价的——在我们不想要对象的地方，也能轻易地使用。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":71,"textOffset":0},"endMeta":{"parentTagName":"P","parentIndex":71,"textOffset":19},"text":"便利的访问是我们使用单例的一个主要原因","id":"7ad774dd-4a0d-4a07-aa04-b5651ddaa5a8","__isHighlightSource":{}},"domElementOffsetTop":7906,"domElementOffsetLeft":40,"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"66703dc4934b65ca1469bcf8"},{"_id":"66703e56934b65ca1469bcfb","createdAt":1718632022585,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"text":"我们需要控制它何时发生","type":"normal","completeText":"在拥有虚拟内存和软性性能需求的PC里，惰性初始化是一个小技巧。 游戏则是另一种状况。初始化系统需要消耗时间：分配内存，加载资源，等等。 如果初始化音频系统消耗了几百个毫秒，我们需要控制它何时发生。 如果在第一次声音播放时惰性初始化它自己，这可能发生在游戏的高潮部分，导致可见的掉帧和断续的游戏体验。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":47,"textOffset":86},"endMeta":{"parentTagName":"P","parentIndex":47,"textOffset":97},"text":"我们需要控制它何时发生","id":"dd7ae5fb-cd2a-4a3e-befa-cd160dcdf8ec","__isHighlightSource":{}},"domElementOffsetTop":5173,"domElementOffsetLeft":145,"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"66703dc4934b65ca1469bcf8"},{"_id":"66703e6e934b65ca1469bcfc","createdAt":1718632046361,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"text":"这段代码是线程安全的，而前面的那个例子不是","type":"normal","completeText":"哪怕是在多线程情况下，C++11标准也保证了本地静态变量只会初始化一次， 因此，假设你有一个现代C++编译器，这段代码是线程安全的，而前面的那个例子不是。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":14,"textOffset":56},"endMeta":{"parentTagName":"P","parentIndex":14,"textOffset":77},"text":"这段代码是线程安全的，而前面的那个例子不是","id":"c7bedc51-fefe-44c8-88c7-eadf10215960","__isHighlightSource":{}},"domElementOffsetTop":1703,"domElementOffsetLeft":225,"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"66703dc4934b65ca1469bcf8"},{"_id":"667040dcd94f4658d651d8a6","createdAt":1718632668725,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"某个按键的代码","type":"normal","completeText":"不需要一堆标识，Heroine只有一个state_状态。 这里我们同时改变了分支顺序。在前面的代码中，我们先判断输入，然后 判断状态。 这让处理某个按键的代码集中到了一处，但处理某个状态的代码分散到了各处。 我们想让处理状态的代码聚在一起，所以先对状态做分支。这样的话：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":32,"textOffset":72},"endMeta":{"parentTagName":"P","parentIndex":32,"textOffset":79},"text":"某个按键的代码","id":"872fc224-48f1-48a8-ad04-37425268665e","__isHighlightSource":{}},"domElementOffsetTop":4051,"domElementOffsetLeft":421,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"667040e1d94f4658d651d8a8","createdAt":1718632673281,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"某个状态的代码","type":"normal","completeText":"不需要一堆标识，Heroine只有一个state_状态。 这里我们同时改变了分支顺序。在前面的代码中，我们先判断输入，然后 判断状态。 这让处理某个按键的代码集中到了一处，但处理某个状态的代码分散到了各处。 我们想让处理状态的代码聚在一起，所以先对状态做分支。这样的话：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":32,"textOffset":89},"endMeta":{"parentTagName":"P","parentIndex":32,"textOffset":96},"text":"某个状态的代码","id":"6f0d2065-af69-4ed0-9cf8-94251473ae1c","__isHighlightSource":{}},"domElementOffsetTop":4075,"domElementOffsetLeft":113,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"6670414fd94f4658d651d8a9","createdAt":1718632783679,"updatedAt":1718632796738,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"每个条件分支都是使用动态分配的机会","type":"normal","completeText":"对于那些思维模式深深沉浸在面向对象的人，每个条件分支都是使用动态分配的机会（在C++中叫做虚方法调用）。 我觉得那就太过于复杂化了。有时候一个if就能满足你的需要了。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":40,"textOffset":21},"endMeta":{"parentTagName":"P","parentIndex":40,"textOffset":38},"text":"每个条件分支都是使用动态分配的机会","id":"73c6b8d4-7e8d-4840-862d-a43240566bd6","__isHighlightSource":{}},"domElementOffsetTop":5651,"domElementOffsetLeft":343,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7","richText":{"ops":[{"insert":"经典\n"}]},"modifiedAt":1718632796738},{"_id":"6670436ad94f4658d651d8aa","createdAt":1718633322077,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":" 那么它存储的唯一数据就是指向虚方法表的指针，用来调用它的方法。 在这种情况下，没理由产生多个实例。毕竟每个实例都完全一样","type":"normal","completeText":"如果状态对象没有其他数据字段， 那么它存储的唯一数据就是指向虚方法表的指针，用来调用它的方法。 在这种情况下，没理由产生多个实例。毕竟每个实例都完全一样。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":54,"textOffset":15},"endMeta":{"parentTagName":"P","parentIndex":54,"textOffset":76},"text":"\n那么它存储的唯一数据就是指向虚方法表的指针，用来调用它的方法。\n在这种情况下，没理由产生多个实例。毕竟每个实例都完全一样","id":"438006d1-aa76-447c-b68e-31e5fdafbc81","__isHighlightSource":{}},"domElementOffsetTop":7374,"domElementOffsetLeft":260,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"66704523d94f4658d651d8ab","createdAt":1718633763061,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"所有事情就是转换到站立状态，站立状态控制贴图","type":"normal","completeText":"它做的所有事情就是转换到站立状态，站立状态控制贴图。 现在我们的状态真正地封装了。 关于入口行为的好事就是，当你进入状态时，不必关心你是从哪个状态转换来的。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":72,"textOffset":3},"endMeta":{"parentTagName":"P","parentIndex":72,"textOffset":25},"text":"所有事情就是转换到站立状态，站立状态控制贴图","id":"4d6c1c12-274a-470f-93e9-7f4add4c7431","__isHighlightSource":{}},"domElementOffsetTop":9780,"domElementOffsetLeft":84,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"6670452ed94f4658d651d8ac","createdAt":1718633774316,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"当你进入状态时，不必关心你是从哪个状态转换来的","type":"normal","completeText":"它做的所有事情就是转换到站立状态，站立状态控制贴图。 现在我们的状态真正地封装了。 关于入口行为的好事就是，当你进入状态时，不必关心你是从哪个状态转换来的。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":72,"textOffset":54},"endMeta":{"parentTagName":"EM","parentIndex":30,"textOffset":2},"text":"当你进入状态时，不必关心你是从哪个状态转换来的","id":"4bab76c5-00d7-41fc-9490-bc79a124ecfa","__isHighlightSource":{}},"domElementOffsetTop":9804,"domElementOffsetLeft":245,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"6670454fd94f4658d651d8ad","createdAt":1718633807652,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"多加几种武器，状态就会指数爆炸","type":"normal","completeText":"多加几种武器，状态就会指数爆炸。 不但增加了大量的状态，也增加了大量的冗余： 持枪和不持枪的状态是完全一样的，只是多了一点负责射击的代码。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":82,"textOffset":0},"endMeta":{"parentTagName":"P","parentIndex":82,"textOffset":15},"text":"多加几种武器，状态就会指数爆炸","id":"d62fffc9-cdac-4286-9731-36ff13b3cd37","__isHighlightSource":{}},"domElementOffsetTop":10406,"domElementOffsetLeft":40,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"66712635820dce772c83c4b9","createdAt":1718691381436,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"text":"含有静态成员变量的类","type":"normal","completeText":"它在运行时实例化。 通常的替代方案是使用含有静态成员变量的类。 我喜欢简单的解决方案，因此我尽可能使用静态类而不是单例，但是静态成员有个限制：自动初始化。 编译器在main()运行前初始化静态变量。 这就意味着不能使用在程序加载时才获取的信息（举个例子，从文件加载的配置）。 这也意味着它们的相互依赖是不可靠的——编译器可不保证以什么样的顺序初始化静态变量。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":18,"textOffset":24},"endMeta":{"parentTagName":"P","parentIndex":18,"textOffset":34},"text":"含有静态成员变量的类","id":"95f799b6-fdde-44b0-b2d0-95477ed23608","__isHighlightSource":{}},"domElementOffsetTop":1915,"domElementOffsetLeft":347,"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"66703dc4934b65ca1469bcf8"},{"_id":"66712916820dce772c83c4ba","createdAt":1718692118708,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"text":"便利的访问，几乎是使用单例模式的全部原因","type":"normal","completeText":"这两个问题中的后者，便利的访问，几乎是使用单例模式的全部原因。 想想日志类。大部分模块都能从记录诊断日志中获益。 但是，如果将Log类的实例传给每个需要这个方法的函数，那就混杂了产生的数据，模糊了代码的意图。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":41,"textOffset":10},"endMeta":{"parentTagName":"P","parentIndex":41,"textOffset":30},"text":"便利的访问，几乎是使用单例模式的全部原因","id":"d474b560-b348-45f0-8ebf-a734aa143206","__isHighlightSource":{}},"domElementOffsetTop":4664,"domElementOffsetLeft":186,"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"66703dc4934b65ca1469bcf8"},{"_id":"66713dea03de3945f40d7dea","createdAt":1718697450644,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"判断输入，然后 判断状态","type":"normal","completeText":"不需要一堆标识，Heroine只有一个state_状态。 这里我们同时改变了分支顺序。在前面的代码中，我们先判断输入，然后 判断状态。 这让处理某个按键的代码集中到了一处，但处理某个状态的代码分散到了各处。 我们想让处理状态的代码聚在一起，所以先对状态做分支。这样的话：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":32,"textOffset":54},"endMeta":{"parentTagName":"P","parentIndex":32,"textOffset":66},"text":"判断输入，然后 判断状态","id":"a72f0d00-a4b6-429d-884c-59a3e012998d","__isHighlightSource":{}},"domElementOffsetTop":4051,"domElementOffsetLeft":174,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"6671407a03de3945f40d7deb","createdAt":1718698106927,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"转换时需要创建状态对象","type":"normal","completeText":"在那种情况下，转换时需要创建状态对象。 这需要每个FSM拥有自己的状态实例。如果我们分配新状态， 那意味着我们需要释放当前的状态。 在这里要小心，由于触发变化的代码是当前状态中的方法，需要删除this，因此需要小心从事。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":62,"textOffset":8},"endMeta":{"parentTagName":"P","parentIndex":62,"textOffset":19},"text":"转换时需要创建状态对象","id":"d8b4ba42-e916-456d-a898-ea70c76aed66","__isHighlightSource":{}},"domElementOffsetTop":7998,"domElementOffsetLeft":143,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"66715db503de3945f40d7dec","createdAt":1718705589136,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/state.html","tags":[],"text":"“在地面上”定义一个类","type":"normal","completeText":"如果这是面向对象的代码而不是状态机的，在状态间分享代码的方式是通过继承。 我们可以为“在地面上”定义一个类处理跳跃和速降。 站立、行走、奔跑和滑铲都从它继承，然后增加各自的附加行为。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":95,"textOffset":43},"endMeta":{"parentTagName":"P","parentIndex":95,"textOffset":54},"text":"“在地面上”定义一个类","id":"eaf42241-bb7d-4119-9a5a-89a2fa197878","__isHighlightSource":{}},"domElementOffsetTop":11251,"domElementOffsetLeft":84,"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","_bookmark":"667040dcd94f4658d651d8a7"},{"_id":"66726fbd4e2f3f8bc9f14a8e","createdAt":1718775741794,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"事情发生在瞬间或者让多个任务同时进行","type":"normal","completeText":"电脑具有强大的序列化处理能力。 它的力量来自于将大的任务分解为小的步骤，这样可以一步接一步的完成。 但是，通常用户需要看到事情发生在瞬间或者让多个任务同时进行。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":1,"textOffset":62},"endMeta":{"parentTagName":"P","parentIndex":1,"textOffset":80},"text":"事情发生在瞬间或者让多个任务同时进行","id":"6e7920b1-348c-471b-b8d6-2e9b07fa26a3","__isHighlightSource":{}},"domElementOffsetTop":478,"domElementOffsetLeft":351,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"66726fca4e2f3f8bc9f14a90","createdAt":1718775754183,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"增量做这些，连续世界的幻觉就会被打破","type":"normal","completeText":"一个典型的例子，也是每个游戏引擎都得掌控的问题，渲染。 当游戏渲染玩家所见的世界时，它同时需要处理一堆东西——远处的山，起伏的丘陵，树木，每个都在各自的循环中处理。 如果在用户观察时增量做这些，连续世界的幻觉就会被打破。 场景必须快速流畅地更新，显示一系列完整的帧，每帧都是立即出现的。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":3,"textOffset":91},"endMeta":{"parentTagName":"P","parentIndex":3,"textOffset":109},"text":"增量做这些，连续世界的幻觉就会被打破","id":"33195250-c668-4985-972a-c24bdff5adf2","__isHighlightSource":{}},"domElementOffsetTop":580,"domElementOffsetLeft":218,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"667270294e2f3f8bc9f14a91","createdAt":1718775849327,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"帧缓冲中","type":"normal","completeText":"帧缓冲中","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"EM","parentIndex":2,"textOffset":0},"endMeta":{"parentTagName":"P","parentIndex":8,"textOffset":17},"text":"帧缓冲中","id":"07259441-2f45-4e69-aff7-9bcb1734fe71","__isHighlightSource":{}},"domElementOffsetTop":858,"domElementOffsetLeft":215,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6672712a4e2f3f8bc9f14a92","createdAt":1718776106991,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"程序一次渲染一个像素，但是显示需要一次全部看到——在这帧中啥也没有，下一帧笑脸全部出现。","type":"normal","completeText":"这就是我们需要这个设计模式的原因。 程序一次渲染一个像素，但是显示需要一次全部看到——在这帧中啥也没有，下一帧笑脸全部出现。 双缓冲解决了这个问题。我会用类比来解释。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":17,"textOffset":18},"endMeta":{"parentTagName":"P","parentIndex":17,"textOffset":62},"text":"程序一次渲染一个像素，但是显示需要一次全部看到——在这帧中啥也没有，下一帧笑脸全部出现。","id":"c4fc048d-6f5f-496b-84eb-528fa5c83f48","__isHighlightSource":{}},"domElementOffsetTop":1402,"domElementOffsetLeft":293,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"667271724e2f3f8bc9f14a93","createdAt":1718776178830,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"两个字节代表表示一个像素点的颜色","type":"normal","completeText":"在大多数电脑上，答案是从帧缓冲中获知这些信息。 帧缓冲是内存中的色素数组，RAM中每两个字节代表表示一个像素点的颜色。 当软管向屏幕喷洒时，它从这个数组中读取颜色值，每次一个字节。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":8,"textOffset":43},"endMeta":{"parentTagName":"P","parentIndex":8,"textOffset":59},"text":"两个字节代表表示一个像素点的颜色","id":"b8042e4d-63d2-4dde-9cde-7c3f01b8979a","__isHighlightSource":{}},"domElementOffsetTop":882,"domElementOffsetLeft":69,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"667271b74e2f3f8bc9f14a94","createdAt":1718776247739,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"不只用一个帧缓冲","type":"normal","completeText":"这就是双缓冲的工作原理， 这就是你看到的几乎每个游戏背后的渲染系统。 不只用一个帧缓冲，我们用两个。其中一个代表现在的帧，即类比中的舞台A，也就是说是显卡读取的那一个。 GPU可以想什么时候扫就什么时候扫。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":22,"textOffset":36},"endMeta":{"parentTagName":"P","parentIndex":22,"textOffset":44},"text":"不只用一个帧缓冲","id":"bf69ada7-2ba2-4297-a098-b05021ac9d6d","__isHighlightSource":{}},"domElementOffsetTop":1859,"domElementOffsetLeft":527,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6672726a4e2f3f8bc9f14a96","createdAt":1718776426627,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"外部的代码","type":"normal","completeText":"定义缓冲类封装了缓冲：一段可改变的状态。 这个缓冲被增量地修改，但我们想要外部的代码将修改视为单一的原子操作。 为了实现这点，类保存了两个缓冲的实例：下一缓冲和当前缓冲。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":26,"textOffset":37},"endMeta":{"parentTagName":"P","parentIndex":26,"textOffset":42},"text":"外部的代码","id":"1f185591-d0a8-445e-8bef-fb9f1c4351d3","__isHighlightSource":{}},"domElementOffsetTop":2142,"domElementOffsetLeft":571,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"667273664e2f3f8bc9f14a97","createdAt":1718776678613,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"改变完成后","type":"normal","completeText":"当信息从缓冲区中读取，它总是读取当前的缓冲区。 当信息需要写到缓存，它总是在下一缓冲区上操作。 当改变完成后，一个交换操作会立刻将当前缓冲区和下一缓冲区交换， 这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":27,"textOffset":49},"endMeta":{"parentTagName":"P","parentIndex":27,"textOffset":54},"text":"改变完成后","id":"8bb60b49-b62e-4d79-aba9-033e5287aec3","__isHighlightSource":{}},"domElementOffsetTop":2244,"domElementOffsetLeft":179,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d06225d92a9baf9b815d","createdAt":1718866018782,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"它们在同一帧中更新的顺序不该对结果有影响。","type":"normal","completeText":"而最终的结果是，一个角色对被扇作出反应可能是在被扇的同一帧或者下一帧， 这完全取决于两个角色在舞台上是如何排序的。 这没能满足我让角色同时反应的需求——它们在同一帧中更新的顺序不该对结果有影响。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":66,"textOffset":76},"endMeta":{"parentTagName":"P","parentIndex":66,"textOffset":97},"text":"它们在同一帧中更新的顺序不该对结果有影响。","id":"7a0d4bb0-8071-47ab-a016-9d9f9c756c00","__isHighlightSource":{}},"domElementOffsetTop":8243,"domElementOffsetLeft":570,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d06e25d92a9baf9b815e","createdAt":1718866030516,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"作出反应可能是在被扇的同一帧或者下一帧","type":"normal","completeText":"而最终的结果是，一个角色对被扇作出反应可能是在被扇的同一帧或者下一帧， 这完全取决于两个角色在舞台上是如何排序的。 这没能满足我让角色同时反应的需求——它们在同一帧中更新的顺序不该对结果有影响。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":66,"textOffset":15},"endMeta":{"parentTagName":"P","parentIndex":66,"textOffset":34},"text":"作出反应可能是在被扇的同一帧或者下一帧","id":"a39110c5-45ee-4d11-8dc3-e8906ed9f530","__isHighlightSource":{}},"domElementOffsetTop":8219,"domElementOffsetLeft":260,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d14925d92a9baf9b815f","createdAt":1718866249648,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"“被扇”状态","type":"normal","completeText":"幸运的是，双缓冲模式可以帮忙。 这次，不是保存两大块“缓冲”，我们缓冲更小粒度的事物：每个角色的“被扇”状态。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":67,"textOffset":48},"endMeta":{"parentTagName":"P","parentIndex":67,"textOffset":54},"text":"“被扇”状态","id":"21525e22-28fd-47ef-81e7-1df632ef0e10","__isHighlightSource":{}},"domElementOffsetTop":8358,"domElementOffsetLeft":155,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d1c925d92a9baf9b8160","createdAt":1718866377055,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"当前状态为读准备，下一状态为写准备。","type":"normal","completeText":"不再使用一个slapped_状态，每个演员现在使用两个。 就像我们之前图形的例子一样，当前状态为读准备，下一状态为写准备。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":68,"textOffset":43},"endMeta":{"parentTagName":"P","parentIndex":68,"textOffset":61},"text":"当前状态为读准备，下一状态为写准备。","id":"a1ae35ac-d248-48bf-8136-e5a5b1761b2d","__isHighlightSource":{}},"domElementOffsetTop":8837,"domElementOffsetLeft":40,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d22725d92a9baf9b8161","createdAt":1718866471627,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"被扇之后的那帧","type":"normal","completeText":"update()函数现在更新所有的角色，然后 交换它们的状态。 最终结果是，角色在实际被扇之后的那帧才能看到巴掌。 这样一来，角色无论在舞台数组中如何排列，都会保持相同的行为。 无论外部的代码如何调用，所有的角色在一帧内同时更新。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":70,"textOffset":43},"endMeta":{"parentTagName":"P","parentIndex":70,"textOffset":50},"text":"被扇之后的那帧","id":"d01b1ed7-1207-4e22-ba40-99b4ed7f0fc1","__isHighlightSource":{}},"domElementOffsetTop":9179,"domElementOffsetLeft":40,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d22e25d92a9baf9b8162","createdAt":1718866478516,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"如何排列，都会保持相同的行为","type":"normal","completeText":"update()函数现在更新所有的角色，然后 交换它们的状态。 最终结果是，角色在实际被扇之后的那帧才能看到巴掌。 这样一来，角色无论在舞台数组中如何排列，都会保持相同的行为。 无论外部的代码如何调用，所有的角色在一帧内同时更新。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":70,"textOffset":73},"endMeta":{"parentTagName":"P","parentIndex":70,"textOffset":87},"text":"如何排列，都会保持相同的行为","id":"46a10f83-c772-4349-b755-690307c65fb9","__isHighlightSource":{}},"domElementOffsetTop":9179,"domElementOffsetLeft":468,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d2a125d92a9baf9b8163","createdAt":1718866593501,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"代码库的其他部分","type":"normal","completeText":"外部代码不能存储对缓存的永久指针。 这是主要限制。 由于我们没有真正地移动数据，本质上做的是周期性地通知代码库的其他部分到别处去寻找缓存， 就像前面的舞台类比一样。这就意味着","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":75,"textOffset":91},"endMeta":{"parentTagName":"P","parentIndex":75,"textOffset":99},"text":"代码库的其他部分","id":"6f3261c1-cc55-442b-b156-44323dfb6d39","__isHighlightSource":{}},"domElementOffsetTop":9609,"domElementOffsetLeft":293,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d2a625d92a9baf9b8164","createdAt":1718866598694,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"不能","type":"normal","completeText":"外部代码不能存储对缓存的永久指针。 这是主要限制。 由于我们没有真正地移动数据，本质上做的是周期性地通知代码库的其他部分到别处去寻找缓存， 就像前面的舞台类比一样。这就意味着代码库的其他部分","mediaType":"blockquote","color":"#92ffaa","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":75,"textOffset":99},"endMeta":{"parentTagName":"P","parentIndex":75,"textOffset":101},"text":"不能","id":"985ee1d8-2d5c-4b82-be92-0ed1755e8ecf","__isHighlightSource":{}},"domElementOffsetTop":9609,"domElementOffsetLeft":410,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d35325d92a9baf9b8165","createdAt":1718866771703,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"但如果想沿用某些缓存中已有的数据","type":"normal","completeText":"你会注意到，当我们绘制第三帧时，缓冲区上的数据是第一帧的，而不是第二帧的。大多数情况下，这不是什么问题——我们通常在绘制之前清空整个帧。但如果想沿用某些缓存中已有的数据，就需要考虑数据其实比期望的更旧。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":78,"textOffset":69},"endMeta":{"parentTagName":"P","parentIndex":78,"textOffset":85},"text":"但如果想沿用某些缓存中已有的数据","id":"bf2a0388-c94f-427b-a621-2661129d7809","__isHighlightSource":{}},"domElementOffsetTop":9902,"domElementOffsetLeft":571,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d36225d92a9baf9b8166","createdAt":1718866786891,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"更旧","type":"normal","completeText":"你会注意到，当我们绘制第三帧时，缓冲区上的数据是第一帧的，而不是第二帧的。大多数情况下，这不是什么问题——我们通常在绘制之前清空整个帧。但如果想沿用某些缓存中已有的数据，就需要考虑数据其实比期望的更旧。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":78,"textOffset":99},"endMeta":{"parentTagName":"P","parentIndex":78,"textOffset":101},"text":"更旧","id":"f6c5efaa-00dc-4109-9256-b475f386ce82","__isHighlightSource":{}},"domElementOffsetTop":9926,"domElementOffsetLeft":491,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d60025d92a9baf9b8167","createdAt":1718867456629,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"text":"较旧的帧","type":"normal","completeText":"在喜剧的例子中，这没问题，因为反正需要清除被扇状态 ——每块缓存的数据每帧都需要接触。 如果不需要接触较旧的帧，可以用通过在多个对象间分散状态来优化，获得使用整块缓存一样的性能。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":89,"textOffset":51},"endMeta":{"parentTagName":"P","parentIndex":89,"textOffset":55},"text":"较旧的帧","id":"e5aaa0ad-92d3-49be-83c7-8d7f5aa154dd","__isHighlightSource":{}},"domElementOffsetTop":10513,"domElementOffsetLeft":295,"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","_bookmark":"66726fbd4e2f3f8bc9f14a8f"},{"_id":"6673d81b4af4052c407aefb2","createdAt":1718867995073,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"不管潜在的硬件条件，以固定速度运行游戏","type":"normal","completeText":"不管潜在的硬件条件，以固定速度运行游戏。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"EM","parentIndex":13,"textOffset":0},"endMeta":{"parentTagName":"EM","parentIndex":13,"textOffset":19},"text":"不管潜在的硬件条件，以固定速度运行游戏","id":"26fbc6f8-2dd3-4435-945a-d0aa869de3d7","__isHighlightSource":{}},"domElementOffsetTop":2273,"domElementOffsetLeft":270,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673d8c04af4052c407aefb4","createdAt":1718868160295,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"件循环作为游戏循环","type":"normal","completeText":"其他的平台不会让你这么轻松地摆脱事件循环。 如果你使用网页浏览器作为平台，事件循环已被内建在浏览器的执行模型深处。 这样，你得用事件循环作为游戏循环。 你会调用requestAnimationFrame()之类的函数，它会回调你的代码，保持游戏继续运行。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":38,"textOffset":65},"endMeta":{"parentTagName":"P","parentIndex":38,"textOffset":74},"text":"件循环作为游戏循环","id":"15eae7bb-f163-43a7-bd39-e1312f32b456","__isHighlightSource":{}},"domElementOffsetTop":3030,"domElementOffsetLeft":407,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673dcda4af4052c407aefb5","createdAt":1718869210186,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"elapsed","type":"normal","completeText":"elapsed","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"SPAN","parentIndex":129,"textOffset":0},"endMeta":{"parentTagName":"SPAN","parentIndex":129,"textOffset":7},"text":"elapsed","id":"5a546bee-2792-4c3c-bfa0-64cea16927d8","__isHighlightSource":{}},"domElementOffsetTop":4615,"domElementOffsetLeft":115,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673dced4af4052c407aefb6","createdAt":1718869229466,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"子弹在真实时间里移动同样多的距离","type":"normal","completeText":"假设有一颗子弹跨过屏幕。 使用固定的时间间隔，在每一帧中，你根据它的速度移动它。 使用变化的时间间隔，你根据过去的时间拉伸速度。 随着时间间隔增加，子弹在每帧间移动得更远。 无论是二十个快的小间隔还是四个慢的大间隔，子弹在真实时间里移动同样多的距离。 这看上去成功了：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":53,"textOffset":108},"endMeta":{"parentTagName":"P","parentIndex":53,"textOffset":124},"text":"子弹在真实时间里移动同样多的距离","id":"79a4a7aa-abec-46b9-ab8c-1927ea0fa742","__isHighlightSource":{}},"domElementOffsetTop":4808,"domElementOffsetLeft":468,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673dd204af4052c407aefb7","createdAt":1718869280251,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"调整渲染","type":"normal","completeText":"我们可以利用这点。 以固定的时间间隔更新游戏，因为这让所有事情变得简单，物理和AI也更加稳定。 但是我们允许灵活调整渲染的时刻，释放一些处理器时间。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":66,"textOffset":56},"endMeta":{"parentTagName":"EM","parentIndex":38,"textOffset":2},"text":"调整渲染","id":"8008b5a5-60c3-4073-9cdb-bba122d9e85a","__isHighlightSource":{}},"domElementOffsetTop":5431,"domElementOffsetLeft":250,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673de624af4052c407aefb8","createdAt":1718869602475,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"固定时间步长模拟","type":"normal","completeText":"幸运的是，我们给自己了一些喘息的空间。 技巧在于我们将渲染拉出了更新循环。 这释放了一大块CPU时间。 最终结果是游戏以固定时间步长模拟，该时间步长与硬件不相关。 只是使用低端硬件的玩家看到的内容会有抖动。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":73,"textOffset":60},"endMeta":{"parentTagName":"EM","parentIndex":45,"textOffset":2},"text":"固定时间步长模拟","id":"bdb7ba9c-a087-441f-b68d-1e1a5f438c41","__isHighlightSource":{}},"domElementOffsetTop":6382,"domElementOffsetLeft":314,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673df014af4052c407aefb9","createdAt":1718869761374,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"事件驱动机制","type":"normal","completeText":"这个选择通常是已经由平台决定的。 如果你在做浏览器中的游戏，很可能你不能编写自己的经典游戏循环。 浏览器本身的事件驱动机制阻碍了这一点。 类似地，如果你使用现存的游戏引擎，你很可能依赖于它的游戏循环而不是自己写一个。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":88,"textOffset":55},"endMeta":{"parentTagName":"P","parentIndex":88,"textOffset":61},"text":"事件驱动机制","id":"68de40f0-d6d8-4d79-8f19-4d5466b64145","__isHighlightSource":{}},"domElementOffsetTop":7628,"domElementOffsetLeft":262,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673dfa44af4052c407aefba","createdAt":1718869924143,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"不阻塞用户输入","type":"normal","completeText":"游戏循环有两个关键部分：不阻塞用户输入和自适应的帧时间步长。 输入部分很直观。关键在于你如何处理时间。 这里有数不尽的游戏可运行的平台， 每个游戏都需要在其中一些平台上运行。 如何适应平台的变化就是关键。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":108,"textOffset":12},"endMeta":{"parentTagName":"P","parentIndex":108,"textOffset":19},"text":"不阻塞用户输入","id":"34366fd6-7204-4f5c-aaa0-f9c88b031176","__isHighlightSource":{}},"domElementOffsetTop":8683,"domElementOffsetLeft":216,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673dfa74af4052c407aefbb","createdAt":1718869927942,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"text":"帧时间步长","type":"normal","completeText":"游戏循环有两个关键部分：不阻塞用户输入和自适应的帧时间步长。 输入部分很直观。关键在于你如何处理时间。 这里有数不尽的游戏可运行的平台， 每个游戏都需要在其中一些平台上运行。 如何适应平台的变化就是关键。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":108,"textOffset":24},"endMeta":{"parentTagName":"P","parentIndex":108,"textOffset":29},"text":"帧时间步长","id":"2f3569bf-538b-4913-a85f-d19c01b62b01","__isHighlightSource":{}},"domElementOffsetTop":8683,"domElementOffsetLeft":392,"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673d81b4af4052c407aefb3"},{"_id":"6673e16c557b25885259bad0","createdAt":1718870380814,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"加像棋盘上的棋子","type":"normal","completeText":"但是如果游戏更加抽象，移动部分不太像活动的角色而更加像棋盘上的棋子， 这个模式通常就不适用了。 在棋类游戏中，你不需要同时模拟所有的部分， 你可能也不需要告诉棋子每帧都更新它们自己。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":22,"textOffset":26},"endMeta":{"parentTagName":"P","parentIndex":22,"textOffset":34},"text":"加像棋盘上的棋子","id":"0c170466-103e-492b-8659-427b10a2e327","__isHighlightSource":{}},"domElementOffsetTop":2631,"domElementOffsetLeft":406,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673e1b8557b25885259bad2","createdAt":1718870456747,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"同时运行","type":"normal","completeText":"你的游戏有很多对象或系统需要同时运行。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":25,"textOffset":14},"endMeta":{"parentTagName":"P","parentIndex":25,"textOffset":18},"text":"同时运行","id":"379cf750-ed5f-47f7-ac1b-e91bfc280803","__isHighlightSource":{}},"domElementOffsetTop":2741,"domElementOffsetLeft":266,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673e460557b25885259bad3","createdAt":1718871136607,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"我们使用patrollingLeft显式地追踪了方向。","type":"normal","completeText":"在这里前后两个版本展示了代码是如何变得复杂的。 左右巡逻需要两个简单的for循环。 通过指定哪个循环在执行，我们追踪了骷髅在移向哪个方向。 现在我们每帧跳出到外层的游戏循环，然后再跳回继续我们之前所做的，我们使用patrollingLeft显式地追踪了方向。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":8,"textOffset":102},"endMeta":{"parentTagName":"P","parentIndex":8,"textOffset":129},"text":"我们使用patrollingLeft显式地追踪了方向。","id":"ba7deb8f-02aa-4f09-aa2f-d75066e6290b","__isHighlightSource":{}},"domElementOffsetTop":1455,"domElementOffsetLeft":381,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673e48a557b25885259bad4","createdAt":1718871178579,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"更新对象的顺序","type":"normal","completeText":"在这个模式中，游戏遍历对象集合，更新每一个对象。 在update()调用中，大多数对象都能够接触到游戏世界的其他部分， 包括现在正在更新的其他对象。这就意味着你更新对象的顺序至关重要。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":38,"textOffset":80},"endMeta":{"parentTagName":"EM","parentIndex":9,"textOffset":2},"text":"更新对象的顺序","id":"dd696ea7-eb20-41fd-9d0b-62848d6c5cff","__isHighlightSource":{}},"domElementOffsetTop":3401,"domElementOffsetLeft":571,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673e4b3557b25885259bad5","createdAt":1718871219858,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"序列更新解决了这点","type":"normal","completeText":"序列更新解决了这点——每次更新都让游戏世界从一个合法状态增量更新到下一个，不会出现引发歧义而需要协调的部分。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":44,"textOffset":0},"endMeta":{"parentTagName":"P","parentIndex":44,"textOffset":9},"text":"序列更新解决了这点","id":"a5fb06cd-e495-4315-a7af-df5bb5039c3d","__isHighlightSource":{}},"domElementOffsetTop":3612,"domElementOffsetLeft":40,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673e5ee557b25885259bad6","createdAt":1718871534513,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"缓存列表对象的数目","type":"normal","completeText":"但这确实表明新对象在它产生的那帧就有机会活动，甚至有可能在玩家看到它之前。 如果你不想发生那种情况，简单的修复方法就是在游戏循环中缓存列表对象的数目，然后只更新那么多数目的对象就停止：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":48,"textOffset":65},"endMeta":{"parentTagName":"P","parentIndex":48,"textOffset":74},"text":"缓存列表对象的数目","id":"47799f4e-af9f-4013-8db5-99454230fb51","__isHighlightSource":{}},"domElementOffsetTop":3860,"domElementOffsetLeft":423,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673e7b9557b25885259bad7","createdAt":1718871993426,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"当游戏业界都明白了这一点，解决方案是使用组件模式","type":"normal","completeText":"当游戏业界都明白了这一点，解决方案是使用组件模式。 使用它，update()是实体的组件而不是在Entity中。 这让你避开了为了定义和重用行为而创建实体所需的复杂类继承层次。相反，你只需混合和组装组件。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":74,"textOffset":0},"endMeta":{"parentTagName":"P","parentIndex":74,"textOffset":24},"text":"当游戏业界都明白了这一点，解决方案是使用组件模式","id":"a150729a-d88f-4e8c-b103-d2d326972d12","__isHighlightSource":{}},"domElementOffsetTop":6188,"domElementOffsetLeft":40,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673eae3557b25885259bad8","createdAt":1718872803556,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"消逝的时间","type":"normal","completeText":"这意味着每次update()调用都需要知道虚拟的时钟转动了多少， 所以你经常可以看到传入消逝的时间。 举个例子，我们可以让骷髅卫士像这样处理变化的时间步长：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":91,"textOffset":44},"endMeta":{"parentTagName":"P","parentIndex":91,"textOffset":49},"text":"消逝的时间","id":"5a593a50-a0b2-4ae5-94c4-76cd4f0cab3d","__isHighlightSource":{}},"domElementOffsetTop":8262,"domElementOffsetLeft":54,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673eb47557b25885259bad9","createdAt":1718872903625,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"它不是虚方","type":"normal","completeText":"如果你使用了这些模式，将update()放在委托类中是很自然的。 在那种情况下，也许主类中仍有update()方法，但是它不是虚方法，可以简单地委托给委托对象。就像这样：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":102,"textOffset":60},"endMeta":{"parentTagName":"P","parentIndex":102,"textOffset":65},"text":"它不是虚方","id":"499e2335-a129-4bdf-9dbd-d10d56124d1c","__isHighlightSource":{}},"domElementOffsetTop":9301,"domElementOffsetLeft":292,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673eb4f557b25885259bada","createdAt":1718872911167,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"法","type":"normal","completeText":"如果你使用了这些模式，将update()放在委托类中是很自然的。 在那种情况下，也许主类中仍有update()方法，但是它不是虚方","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":102,"textOffset":65},"endMeta":{"parentTagName":"P","parentIndex":102,"textOffset":66},"text":"法","id":"cc870803-5112-4cca-9579-485d6d1c8b33","__isHighlightSource":{}},"domElementOffsetTop":9301,"domElementOffsetLeft":365,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673eca3557b25885259badb","createdAt":1718873251485,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"不活跃对象的可能数量","type":"normal","completeText":"方法选择的度量标准是不活跃对象的可能数量。 数量越多，用分离的集合避免在核心游戏循环中用到它们就更有用。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":112,"textOffset":10},"endMeta":{"parentTagName":"P","parentIndex":112,"textOffset":20},"text":"不活跃对象的可能数量","id":"10b30d89-80ec-4bbd-93a4-a2474dab56ac","__isHighlightSource":{}},"domElementOffsetTop":10010,"domElementOffsetLeft":186,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673eca8557b25885259badc","createdAt":1718873256872,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"分离的集合","type":"normal","completeText":"方法选择的度量标准是不活跃对象的可能数量。 数量越多，用分离的集合避免在核心游戏循环中用到它们就更有用。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":112,"textOffset":28},"endMeta":{"parentTagName":"P","parentIndex":112,"textOffset":33},"text":"分离的集合","id":"1592e8c5-9446-4414-b2b4-208da7455cef","__isHighlightSource":{}},"domElementOffsetTop":10010,"domElementOffsetLeft":439,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"6673ee606ba5d5e244e85c6f","createdAt":1718873696754,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"类添加错误的速度会明显快于添加功能的速度。","type":"normal","completeText":"这工作对能驯服他的少数人来说是有趣的，但对其他人而言是地狱。 这么大的类意味着，即使是看似微不足道的变化亦可有深远的影响。 很快，为类添加错误的速度会明显快于添加功能的速度。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":7,"textOffset":66},"endMeta":{"parentTagName":"P","parentIndex":7,"textOffset":87},"text":"类添加错误的速度会明显快于添加功能的速度。","id":"01443998-2454-4d0f-bb98-3df4c1432fe8","__isHighlightSource":{}},"domElementOffsetTop":791,"domElementOffsetLeft":439,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673eec36ba5d5e244e85c71","createdAt":1718873795351,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"Bjorn拥有这个部件的一个实例。","type":"normal","completeText":"Bjorn拥有这个部件的一个实例。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"CODE","parentIndex":5,"textOffset":0},"endMeta":{"parentTagName":"P","parentIndex":14,"textOffset":110},"text":"Bjorn拥有这个部件的一个实例。","id":"528de637-9600-4e37-b86b-d299d31af336","__isHighlightSource":{}},"domElementOffsetTop":1264,"domElementOffsetLeft":190,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673ef3e6ba5d5e244e85c72","createdAt":1718873918808,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"致命菱形结构","type":"normal","completeText":"我们有GameObject基类，包含位置和方向之类的通用部分。 Zone继承它，增加了碰撞检测。 同样，Decoration继承GameObject，并增加了渲染。 Prop继承Zone，因此它可以重用碰撞代码。 然而，Prop不能同时继承Decoration来重用渲染， 否则就会造成致命菱形结构。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":25,"textOffset":143},"endMeta":{"parentTagName":"P","parentIndex":25,"textOffset":149},"text":"致命菱形结构","id":"4b24f781-ac2c-4749-a2b3-442c6503b7ef","__isHighlightSource":{}},"domElementOffsetTop":2335,"domElementOffsetLeft":40,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673ef826ba5d5e244e85c73","createdAt":1718873986359,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"子类将彻底消失","type":"normal","completeText":"现在，让我们尝试用组件。子类将彻底消失。 取而代之的是一个GameObject类和两个组件类：PhysicsComponent和GraphicsComponent。 装饰是个简单的GameObject，包含GraphicsComponent但没有PhysicsComponent。 区域与其恰好相反，而道具包含两种组件。 没有代码重复，没有多重继承，只有三个类，而不是四个。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":29,"textOffset":12},"endMeta":{"parentTagName":"P","parentIndex":29,"textOffset":19},"text":"子类将彻底消失","id":"4be1df2a-eedb-4dd3-972c-e02208f84981","__isHighlightSource":{}},"domElementOffsetTop":2468,"domElementOffsetLeft":218,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673f04c6ba5d5e244e85c74","createdAt":1718874188737,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"实体被简化为组件的容器。","type":"normal","completeText":"单一实体跨越了多个领域。为了保持领域之间相互分离，将每部分代码放入各自的组件类中。 实体被简化为组件的容器。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":34,"textOffset":42},"endMeta":{"parentTagName":"P","parentIndex":34,"textOffset":54},"text":"实体被简化为组件的容器。","id":"cfb2d0c1-398e-4f19-b768-de57c58b1618","__isHighlightSource":{}},"domElementOffsetTop":2719,"domElementOffsetLeft":87,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673f1816ba5d5e244e85c75","createdAt":1718874497507,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"多一层跳","type":"normal","completeText":"使用组件的另一后果是，需要多一层跳转才能做要做的事。 拿到容器对象，获得相应的组件，然后 你才能做想做的事情。 在性能攸关的内部循环中，这种跳转也许会导致糟糕的性能。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":44,"textOffset":13},"endMeta":{"parentTagName":"P","parentIndex":44,"textOffset":17},"text":"多一层跳","id":"6f6f9a26-d4eb-472c-8ebf-838d84b8e679","__isHighlightSource":{}},"domElementOffsetTop":3198,"domElementOffsetLeft":230,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673f1866ba5d5e244e85c76","createdAt":1718874502553,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"容器对象","type":"normal","completeText":"使用组件的另一后果是，需要多一层跳转才能做要做的事。 拿到容器对象，获得相应的组件，然后 你才能做想做的事情。 在性能攸关的内部循环中，这种跳转也许会导致糟糕的性能。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":44,"textOffset":29},"endMeta":{"parentTagName":"P","parentIndex":44,"textOffset":33},"text":"容器对象","id":"2866627a-6494-40b3-8e61-43500e944d27","__isHighlightSource":{}},"domElementOffsetTop":3198,"domElementOffsetLeft":454,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673f3fd6ba5d5e244e85c77","createdAt":1718875133376,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"只关于将组件变为类","type":"normal","completeText":"说明组件模式尤其困难。 如果看不到它解耦的各个领域的代码，你就不能获得正确的体会， 因此我会多写一些有关于Bjorn的代码。 这个模式事实上只关于将组件变为类，但类中的代码可以帮助表明类是做什么用的。 它是伪代码——它调用了其他不存在的类——但这应该可以让你理解我们正在做什么。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":47,"textOffset":70},"endMeta":{"parentTagName":"EM","parentIndex":19,"textOffset":1},"text":"只关于将组件变为类","id":"8a8c9c3f-5b4b-4616-b04a-0dd4cf5cbf39","__isHighlightSource":{}},"domElementOffsetTop":3449,"domElementOffsetLeft":427,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673f6886ba5d5e244e85c78","createdAt":1718875784893,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"无需为Bjorn建立具体类，就能构建拥有所有Bjorn行为的对象。","type":"normal","completeText":"现在我们无需为Bjorn建立具体类，就能构建拥有所有Bjorn行为的对象。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":84,"textOffset":4},"endMeta":{"parentTagName":"P","parentIndex":84,"textOffset":37},"text":"无需为Bjorn建立具体类，就能构建拥有所有Bjorn行为的对象。","id":"d9442323-4533-427c-b830-ff147b647a81","__isHighlightSource":{}},"domElementOffsetTop":10327,"domElementOffsetLeft":98,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673f7436ba5d5e244e85c79","createdAt":1718875971734,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"谁将它们拼到一起","type":"normal","completeText":"一旦将单块对象分割为多个分离的组件，就需要决定谁将它们拼到一起。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":90,"textOffset":23},"endMeta":{"parentTagName":"P","parentIndex":90,"textOffset":31},"text":"谁将它们拼到一起","id":"ea93897c-89ef-43ee-87ac-af65a66e25cc","__isHighlightSource":{}},"domElementOffsetTop":10718,"domElementOffsetLeft":371,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"6673f8176ba5d5e244e85c7a","createdAt":1718876183869,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/component.html","tags":[],"text":"外部代码提供组件","type":"normal","completeText":"如果我们允许外部代码提供组件，好处是也可以传递派生的组件类型。 这样，对象只知道组件接口而不知道组件的具体类型。这是一个很好的封装结构。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":97,"textOffset":6},"endMeta":{"parentTagName":"P","parentIndex":97,"textOffset":14},"text":"外部代码提供组件","id":"5a489eeb-6dc1-4f88-aa85-2e5cd29d2183","__isHighlightSource":{}},"domElementOffsetTop":11033,"domElementOffsetLeft":153,"title":"组件模式 · Decoupling Patterns · 游戏设计模式","_bookmark":"6673ee606ba5d5e244e85c70"},{"_id":"667430865fc79226dfff16d3","createdAt":1718890630370,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"text":"分离了游戏世界的构建和实现","type":"normal","completeText":"这个模式让我们分离了游戏世界的构建和实现。 这同样能让我们灵活地使用分散的数据文件或关卡编辑器来构建游戏世界。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":83,"textOffset":7},"endMeta":{"parentTagName":"EM","parentIndex":19,"textOffset":2},"text":"分离了游戏世界的构建和实现","id":"e2cf8c8f-b1a7-40ff-a452-7f36238f2b82","__isHighlightSource":{}},"domElementOffsetTop":7638,"domElementOffsetLeft":143,"title":"更新方法 · Sequencing Patterns · 游戏设计模式","_bookmark":"6673e16c557b25885259bad1"},{"_id":"667530174eed5fad88e215c6","createdAt":1718956055142,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"法术都是硬编码","type":"normal","completeText":"像现在的许多游戏一样，我们也需要在发售之后更新游戏，修复漏洞或是添加新内容。 如果所有法术都是硬编码的，那么每次修改都意味着要给游戏的可执行文件打补丁。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":9,"textOffset":43},"endMeta":{"parentTagName":"P","parentIndex":9,"textOffset":50},"text":"法术都是硬编码","id":"37ee7fb7-664f-4488-80dc-4c3d92dd6885","__isHighlightSource":{}},"domElementOffsetTop":937,"domElementOffsetLeft":98,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667530274eed5fad88e215c8","createdAt":1718956071272,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"每个模组制造者","type":"normal","completeText":"再扯远一点，假设我们还想支持模组。我们想让玩家创造自己的法术。 如果这些法术都是硬编码的，那就意味着每个模组制造者都得拥有编译游戏的整套工具链， 我们也就不得不开放源代码，如果他们的自创法术上有个漏洞，那么就会把其他人的游戏也搞崩溃。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":10,"textOffset":50},"endMeta":{"parentTagName":"P","parentIndex":10,"textOffset":57},"text":"每个模组制造者","id":"96a3b50e-32b2-4422-b9f1-a6096e62cb22","__isHighlightSource":{}},"domElementOffsetTop":991,"domElementOffsetLeft":201,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667530524eed5fad88e215c9","createdAt":1718956114039,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"与游戏核心隔绝的沙箱","type":"normal","completeText":"很明显实现引擎的编程语言不是个好选择。 我们需要将法术放在与游戏核心隔绝的沙箱中。 我们想要它们易于修改，易于加载，并与其他可执行部分相隔离。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":11,"textOffset":29},"endMeta":{"parentTagName":"P","parentIndex":11,"textOffset":39},"text":"与游戏核心隔绝的沙箱","id":"c65b9e77-2da9-4277-a2e6-1bd4891ce0f8","__isHighlightSource":{}},"domElementOffsetTop":1106,"domElementOffsetLeft":454,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667531144eed5fad88e215ca","createdAt":1718956308699,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"是对数据缓存的谋杀","type":"normal","completeText":"顺着那些指针遍历子表达式是对数据缓存的谋杀。同时，虚函数调用是对指令缓存的屠戮。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":37,"textOffset":12},"endMeta":{"parentTagName":"P","parentIndex":37,"textOffset":21},"text":"是对数据缓存的谋杀","id":"8f00b2c3-dc30-47b7-a13d-09021ce57eb7","__isHighlightSource":{}},"domElementOffsetTop":3262,"domElementOffsetLeft":238,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667531254eed5fad88e215cb","createdAt":1718956325896,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"指令缓存的屠戮","type":"normal","completeText":"顺着那些指针遍历子表达式是对数据缓存的谋杀。同时，虚函数调用是对指令缓存的屠戮。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":37,"textOffset":32},"endMeta":{"parentTagName":"P","parentIndex":37,"textOffset":39},"text":"指令缓存的屠戮","id":"75268ee9-526e-4163-8492-74f269cb1a54","__isHighlightSource":{}},"domElementOffsetTop":3262,"domElementOffsetLeft":528,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"6675321c4eed5fad88e215cc","createdAt":1718956572577,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"游戏实现语言","type":"normal","completeText":"这是本书中最复杂的模式，无法轻易地加入游戏中。这个模式应当用在你有许多行为需要定义，而游戏实现语言因为如下原因不适用时：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":54,"textOffset":43},"endMeta":{"parentTagName":"P","parentIndex":54,"textOffset":49},"text":"游戏实现语言","id":"70bca5e0-058d-437f-8376-440802bd9ebc","__isHighlightSource":{}},"domElementOffsetTop":4122,"domElementOffsetLeft":112,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667532214eed5fad88e215cd","createdAt":1718956577354,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"不适用","type":"normal","completeText":"这是本书中最复杂的模式，无法轻易地加入游戏中。这个模式应当用在你有许多行为需要定义，而游戏实现语言因为如下原因不适用时：","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":54,"textOffset":55},"endMeta":{"parentTagName":"P","parentIndex":54,"textOffset":58},"text":"不适用","id":"2b271b01-47cb-43c2-8d05-0c74eb097e37","__isHighlightSource":{}},"domElementOffsetTop":4122,"domElementOffsetLeft":285,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667532ed4eed5fad88e215ce","createdAt":1718956781275,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"可被数据控制","type":"normal","completeText":"现在让我们把这种程序化的API转化为可被数据控制的东西。 从小处开始，然后慢慢拓展到整体。 现在，要去除方法的所有参数。 假设set__()方法总影响玩家的巫师，总直接将状态设为最大值。 同样，FX操作总是播放一个硬编码的声音和粒子效果。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":81,"textOffset":18},"endMeta":{"parentTagName":"P","parentIndex":81,"textOffset":24},"text":"可被数据控制","id":"76e37ef3-d36c-4544-af1b-ec0e0acde042","__isHighlightSource":{}},"domElementOffsetTop":5750,"domElementOffsetLeft":280,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667533584eed5fad88e215cf","createdAt":1718956888824,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"最里面的子表达式","type":"normal","completeText":"要执行复杂的嵌套表达式，得先从最里面的子表达式开始。 计算完里面的，将结果作为参数向外流向包含它们的表达式， 直到得出最终结果，整个表达式就算完了。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":91,"textOffset":15},"endMeta":{"parentTagName":"P","parentIndex":91,"textOffset":23},"text":"最里面的子表达式","id":"4b98a568-2965-40a7-b14d-ae55237fa018","__isHighlightSource":{}},"domElementOffsetTop":7165,"domElementOffsetLeft":260,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667533644eed5fad88e215d0","createdAt":1718956900678,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"套对象组成的树","type":"normal","completeText":"解释器模式将其明确地表现为嵌套对象组成的树，但我们需要指令速度达到列表的速度。我们仍然需要确保子表达式的结果正确地向外传递给包括它的表达式。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":93,"textOffset":14},"endMeta":{"parentTagName":"P","parentIndex":93,"textOffset":21},"text":"套对象组成的树","id":"fffeefb5-54db-4371-b011-2f2ff2340b8b","__isHighlightSource":{}},"domElementOffsetTop":7219,"domElementOffsetLeft":252,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667533694eed5fad88e215d1","createdAt":1718956905565,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"列表的速度","type":"normal","completeText":"解释器模式将其明确地表现为嵌套对象组成的树，但我们需要指令速度达到列表的速度。我们仍然需要确保子表达式的结果正确地向外传递给包括它的表达式。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":93,"textOffset":33},"endMeta":{"parentTagName":"P","parentIndex":93,"textOffset":38},"text":"列表的速度","id":"19107464-8f08-438a-9d70-ccc37eb744cf","__isHighlightSource":{}},"domElementOffsetTop":7219,"domElementOffsetLeft":540,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"},{"_id":"667537616698adc305c3abd3","createdAt":1718957921025,"updatedAt":0,"_objectStore":"marks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"text":"每当数据需要从一条指令传到另一条，它就得通过栈","type":"normal","completeText":"虚拟机用内部栈保存值。在例子中，指令交互的值只有一种，那就是数字， 所以可以使用简单的int数组。 每当数据需要从一条指令传到另一条，它就得通过栈。","mediaType":"blockquote","color":"#ffad2a","highlightSource":{"startMeta":{"parentTagName":"P","parentIndex":96,"textOffset":50},"endMeta":{"parentTagName":"P","parentIndex":96,"textOffset":73},"text":"每当数据需要从一条指令传到另一条，它就得通过栈","id":"3a2341f2-196f-4a42-8536-2fef6b416da2","__isHighlightSource":{}},"domElementOffsetTop":7617,"domElementOffsetLeft":169,"title":"字节码 · Behavioral Patterns · 游戏设计模式","_bookmark":"667530174eed5fad88e215c7"}],"bookmarks":[{"_id":"666ee6cc45699577f55fc6ca","createdAt":1718544076781,"updatedAt":0,"_objectStore":"bookmarks","url":"https://web-highlights.com/blog/welcome/","tags":[],"title":"Welcome To Web Highlights 📚 🏷️ ✍️","origin":"web-highlights.com","language":"en","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"Welcome To Web Highlights 📚 🏷️ ✍️","description":"Hey there, I am Marius 👋  I originally developed this Chrome highlighter for myself to better organize and re-find my research on the internet. In this article, I want to ensure you get off to a good start -  I hope you learn to love the app as much as I","image":{"url":"https://images.unsplash.com/photo-1533745848184-3db07256e163?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHdlbGNvbWV8ZW58MHx8fHwxNjY5MzkyMzgy&ixlib=rb-4.0.3&q=80&w=2000","width":"2000","height":"1125"},"url":"https://web-highlights.com/blog/welcome/","type":"article","favicon":"https://web-highlights.com/favicon.ico","date":"2022-11-25T15:59:05.000Z"},"canonicalLink":null},{"_id":"666ee7080968d573cc0d24d1","createdAt":1718544136212,"updatedAt":1718544289900,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/observer.html","tags":[],"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"观察者模式 · Design Patterns Revisited · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/observer.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null,"modifiedAt":1718544143767},{"_id":"667034993e6a0feaeb6c4ea0","createdAt":1718629529748,"updatedAt":0,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/prototype.html","tags":[],"title":"原型模式 · Design Patterns Revisited · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"原型模式 · Design Patterns Revisited · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/prototype.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null},{"_id":"66703dc4934b65ca1469bcf8","createdAt":1718631876460,"updatedAt":1718631898060,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/singleton.html","tags":[],"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"单例模式 · Design Patterns Revisited · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/singleton.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null,"modifiedAt":0},{"_id":"667040dcd94f4658d651d8a7","createdAt":1718632668737,"updatedAt":1718632796739,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/state.html","tags":[],"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"状态模式 · Design Patterns Revisited · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/state.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null,"modifiedAt":1718632790172},{"_id":"66726fbd4e2f3f8bc9f14a8f","createdAt":1718775741805,"updatedAt":0,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/double-buffer.html","tags":[],"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"双缓冲模式 · Sequencing Patterns · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/double-buffer.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null},{"_id":"6673d81b4af4052c407aefb3","createdAt":1718867995085,"updatedAt":0,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/game-loop.html","tags":[],"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"游戏循环 · Sequencing Patterns · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/game-loop.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null},{"_id":"6673e16c557b25885259bad1","createdAt":1718870380826,"updatedAt":0,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/update-method.html","tags":[],"title":"更新方法 · Sequencing Patterns · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"更新方法 · Sequencing Patterns · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/update-method.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null},{"_id":"6673ee606ba5d5e244e85c70","createdAt":1718873696767,"updatedAt":0,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/component.html","tags":[],"title":"组件模式 · Decoupling Patterns · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"组件模式 · Decoupling Patterns · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/component.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null},{"_id":"667530174eed5fad88e215c7","createdAt":1718956055154,"updatedAt":0,"_objectStore":"bookmarks","url":"https://gpp.tkchu.me/bytecode.html","tags":[],"title":"字节码 · Behavioral Patterns · 游戏设计模式","origin":"gpp.tkchu.me","language":"zh-CN","permission":"PRIVATE","type":"normal","isStarred":false,"meta":{"title":"字节码 · Behavioral Patterns · 游戏设计模式","description":"","image":{},"url":"https://gpp.tkchu.me/bytecode.html","favicon":"https://gpp.tkchu.me/images/favicon-32x32.png"},"canonicalLink":null}],"chromeSettings":{"_id":"666ee6c0e0c6ac079c28671e","createdAt":1718544064474,"updatedAt":1718957921058,"_objectStore":"chromesettings","showMarkerPopup":true,"showLeftSidebarWidget":false,"showToolboxAutomatically":false,"defaultHighlightColor":"#ffad2a","recentColors":["#ffad2a","#ffad2a","#ffad2a","#ffad2a","#ffad2a","#ffad2a","#ffad2a","#ffad2a","#ffad2a","#ffad2a"],"blacklistedUrls":[],"lastSync":1718544064474,"showLearningTeaser":false,"chromeRatingPromptDismissed":true,"sidebarOptions":{"sidebarWidth":400,"sidebarAlignment":"left","sidebarBehavior":"push"},"preferredColorMode":"dark","showBackupDialogPrompt":true,"backupDialogPromptInterval":100,"signUpPromptDismissed":true,"dismissedBackupPromptIds":["backup_prompt_dismissed_100"]}}